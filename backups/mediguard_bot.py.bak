"""
MediGuard AI WhatsApp Bot
Clinical triage and prediction system via WhatsApp.
"""

import os
import json
import re
import sqlite3
from datetime import datetime
from typing import Any, Dict, List, Optional
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, request
from twilio.twiml.messaging_response import MessagingResponse
from twilio.rest import Client

from mediguard.models.scaler import BiomarkerScaler
from mediguard.models.predictor import MediGuardPredictor
from mediguard.parsers.input_parser import BiomarkerInputParser
from mediguard.parsers.lab_report_ocr import LabReportOCR
from mediguard.parsers.biomarker_extractor import BiomarkerExtractor
from mediguard.knowledge.rag_engine import MedicalRAGEngine
from mediguard.utils.security import SecureLogger, validate_input_security, anonymize_user_id
from mediguard.utils.formatters import (
    format_prediction_response,
    format_biomarker_summary,
    format_help_message,
    format_template_message,
    chunk_message,
)
from mediguard.utils.media_handler import MediaHandler, extract_media_from_twilio_request


# ---------------------------
# Configuration & Initialization
# ---------------------------

load_dotenv()

DB_PATH = os.path.join(os.path.dirname(__file__), "mediguard.db")

TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_WHATSAPP_FROM = os.getenv("TWILIO_WHATSAPP_FROM")

if not TWILIO_ACCOUNT_SID or not TWILIO_AUTH_TOKEN:
    missing = []
    if not TWILIO_ACCOUNT_SID:
        missing.append("TWILIO_ACCOUNT_SID")
    if not TWILIO_AUTH_TOKEN:
        missing.append("TWILIO_AUTH_TOKEN")
    raise RuntimeError(
        f"Missing required environment variables: {', '.join(missing)}. Set them in .env."
    )

twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)

app = Flask(__name__)

# Initialize MediGuard components
scaler = BiomarkerScaler()
predictor = MediGuardPredictor()
parser = BiomarkerInputParser()
rag_engine = MedicalRAGEngine()
secure_logger = SecureLogger(DB_PATH)
media_handler = MediaHandler()
ocr_engine = LabReportOCR(use_llm=True)
biomarker_extractor = BiomarkerExtractor(use_llm=True)


# ---------------------------
# Database Helpers
# ---------------------------

def get_db_connection() -> sqlite3.Connection:
    """Get database connection."""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    """Initialize database tables."""
    conn = get_db_connection()
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS sessions (
            user_id TEXT PRIMARY KEY,
            mode TEXT DEFAULT 'idle',
            last_prediction TEXT,
            last_references TEXT,
            pending_confirmation INTEGER DEFAULT 0,
            pending_values TEXT,
            updated_at TEXT
        )
        """
    )

    conn.commit()
    conn.close()

    # Initialize secure logging tables
    secure_logger._init_db()


def get_session(user_id: str) -> sqlite3.Row:
    """Get or create user session."""
    conn = get_db_connection()
    cur = conn.execute("SELECT * FROM sessions WHERE user_id=?", (user_id,))
    row = cur.fetchone()

    if row is None:
        conn.execute(
            "INSERT INTO sessions (user_id, updated_at) VALUES (?, ?)",
            (user_id, datetime.utcnow().isoformat()),
        )
        conn.commit()
        cur = conn.execute("SELECT * FROM sessions WHERE user_id=?", (user_id,))
        row = cur.fetchone()

    conn.close()
    assert row is not None
    return row


def update_session(user_id: str, **kwargs: Any) -> None:
    """Update session data."""
    if not kwargs:
        return

    columns = ", ".join([f"{k}=?" for k in kwargs.keys()])
    values = list(kwargs.values())
    values.extend([datetime.utcnow().isoformat(), user_id])

    conn = get_db_connection()
    conn.execute(
        f"UPDATE sessions SET {columns}, updated_at=? WHERE user_id=?",
        values,
    )
    conn.commit()
    conn.close()


# ---------------------------
# Bot Logic
# ---------------------------

def handle_message(user_id: str, text: str) -> str:
    """
    Robust message handler for MediGuard bot with comprehensive error handling.
    
    This function processes all incoming text messages with multiple layers of
    error handling to ensure it never breaks and always returns a valid response.

    Args:
        user_id: WhatsApp user ID
        text: Message text from user

    Returns:
        Response message (always returns a valid string, never None or empty)
    """
    # ============================================================
    # Layer 1: Input Validation & Sanitization
    # ============================================================
    try:
        # Validate inputs
        if not user_id or not isinstance(user_id, str):
            user_id = "unknown"
        if not text:
            text = ""
        if not isinstance(text, str):
            text = str(text)
        
        # Sanitize: limit input size to prevent memory issues (max 50KB)
        MAX_INPUT_SIZE = 50 * 1024  # 50KB
        if len(text) > MAX_INPUT_SIZE:
            text = text[:MAX_INPUT_SIZE]
            print(f"[WARN] Input truncated to {MAX_INPUT_SIZE} chars for user {user_id}")
        
        # Security validation
        is_valid, error_msg = validate_input_security(text)
        if not is_valid:
            secure_logger.audit("security_violation", user_id, {"reason": error_msg})
            return f"Security error: {error_msg}"
        
        # Normalize text
        text_original = text
        text = text.strip()
        text_lower = text.lower().strip()
        
        # Log incoming message (with error handling)
        try:
            secure_logger.log_event(
                user_id,
                "message_received",
                {"event_type": "user_message", "timestamp": datetime.utcnow().isoformat()},
            )
        except Exception as log_err:
            print(f"[WARN] Failed to log message event: {str(log_err)}")
            # Continue processing even if logging fails
        
    except Exception as e:
        print(f"[ERROR] Input validation error: {str(e)}")
        import traceback
        traceback.print_exc()
        return "Error processing your message. Please try again or type 'help'."

    # ============================================================
    # Layer 2: Command Processing (with error handling)
    # ============================================================
    try:
        # Handle empty/whitespace-only messages
        if not text or len(text.strip()) == 0:
            return "I received an empty message. Type 'help' for instructions."
        
        # Commands (each wrapped in try-catch for robustness)
        if text_lower in ["/start", "start", "hello", "hi"]:
            try:
                return handle_start()
            except Exception as e:
                print(f"[ERROR] Error in handle_start: {str(e)}")
                return "Welcome to MediGuard AI! Type 'help' for instructions."

        if text_lower in ["help", "/help"]:
            try:
                return format_help_message()
            except Exception as e:
                print(f"[ERROR] Error in format_help_message: {str(e)}")
                return (
                    "MediGuard AI - Clinical Triage Assistant\n\n"
                    "Send blood test values in JSON, key=value, or CSV format.\n"
                    "Type 'template' for an example."
                )

        if text_lower in ["template", "get template", "show template"]:
            try:
                return handle_template_request(text_lower)
            except Exception as e:
                print(f"[ERROR] Error in handle_template_request: {str(e)}")
                return (
                    "JSON Template:\n"
                    '{"hemoglobin": 14.5, "wbc_count": 7.2, ...}\n\n'
                    "Type 'help' for more formats."
                )

        if text_lower in ["reset", "/reset", "clear"]:
            try:
                return handle_reset(user_id)
            except Exception as e:
                print(f"[ERROR] Error in handle_reset: {str(e)}")
                return "Session reset. You can start fresh now."

        if "explain more" in text_lower:
            try:
                return handle_explain_more(user_id)
            except Exception as e:
                print(f"[ERROR] Error in handle_explain_more: {str(e)}")
                return "No previous prediction found. Send your lab results first."

        if "show sources" in text_lower or "references" in text_lower:
            try:
                return handle_show_sources(user_id)
            except Exception as e:
                print(f"[ERROR] Error in handle_show_sources: {str(e)}")
                return "No references available. Send your lab results first."
    
    except Exception as e:
        print(f"[ERROR] Command processing error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Continue to next processing layer

    # ============================================================
    # Layer 3: Biomarker Input Parsing (JSON/key-value/CSV)
    # ============================================================
    try:
        print(f"[DEBUG] Attempting to parse biomarker input...")
        parsed_values, parse_errors = parser.parse(text)
        
        if parsed_values is not None:
            # Successfully parsed biomarker values
            print(f"[DEBUG] Successfully parsed biomarker input: {len(parsed_values)} values")
            try:
                return handle_prediction_request(user_id, parsed_values)
            except Exception as e:
                print(f"[ERROR] Error in handle_prediction_request: {str(e)}")
                import traceback
                traceback.print_exc()
                return (
                    f"Error processing your lab results: {str(e)}\n\n"
                    "Please check your input format and try again.\n"
                    "Type 'help' for instructions or 'template' for an example."
                )
        else:
            print(f"[DEBUG] Biomarker parsing failed: {parse_errors}")
    
    except Exception as e:
        print(f"[ERROR] Biomarker parsing error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Continue to next processing layer

    # ============================================================
    # Layer 4: URL Detection (for PDF/image/Drive links)
    # ============================================================
    try:
        # Only check for URLs if message contains URL-like patterns
        if "http://" in text or "https://" in text or "drive.google.com" in text:
            # Check for direct file URLs (PDF/image)
            url_pattern = r'https?://[^\s]+\.(pdf|jpg|jpeg|png|gif|bmp)(\?[^\s]*)?'
            url_match = re.search(url_pattern, text, re.IGNORECASE)
            if url_match:
                url = url_match.group(0).split('?')[0]  # Remove query params
                print(f"[INFO] Detected file URL in message: {url[:100]}...")
                try:
                    fake_media_info = {
                        "num_media": 1,
                        "media_url": url,
                        "media_content_type": "application/pdf" if url.lower().endswith('.pdf') else "image/jpeg",
                        "media_sid": None,
                        "message_type": "url",
                        "filename": url.split('/')[-1].split('?')[0],
                    }
                    return handle_media_upload(user_id, fake_media_info, {})
                except Exception as e:
                    print(f"[ERROR] Error processing file URL: {str(e)}")
                    return (
                        f"Error processing file URL: {str(e)}\n\n"
                        "Please ensure the URL is publicly accessible and try again."
                    )
            
            # Check for Google Drive URLs
            google_drive_pattern = r'https?://drive\.google\.com/file/d/([a-zA-Z0-9_-]+)'
            gd_match = re.search(google_drive_pattern, text, re.IGNORECASE)
            if gd_match:
                file_id = gd_match.group(1)
                original_url = text.strip()
                print(f"[INFO] ========== GOOGLE DRIVE URL DETECTED ==========")
                print(f"[INFO] Original URL: {original_url}")
                print(f"[INFO] Extracted File ID: {file_id}")
                
                # Pass the ORIGINAL URL to download_media - it will handle conversion
                # This avoids double conversion issues
                print(f"[INFO] Passing original URL to download handler (will convert internally)...")
                try:
                    fake_media_info = {
                        "num_media": 1,
                        "media_url": original_url,  # Pass original URL, let download_media convert it
                        "media_content_type": "application/pdf",
                        "media_sid": None,
                        "message_type": "url",
                        "filename": "lab_report.pdf",
                    }
                    print(f"[INFO] Calling handle_media_upload with Google Drive URL...")
                    return handle_media_upload(user_id, fake_media_info, {})
                except Exception as e:
                    print(f"[ERROR] Exception processing Google Drive URL: {str(e)}")
                    import traceback
                    traceback.print_exc()
                    return (
                        f"Error processing Google Drive link: {str(e)}\n\n"
                        "Please ensure the file is shared with 'Anyone with the link' and try again."
                    )
    
    except Exception as e:
        print(f"[ERROR] URL detection error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Continue to next processing layer

    # ============================================================
    # Layer 5: Query Processing (for general medical questions)
    # ============================================================
    try:
        # Only process as query if message is substantial (more than 10 chars)
        if len(text.strip()) > 10:
            try:
                return handle_query(text)
            except Exception as e:
                print(f"[ERROR] Error in handle_query: {str(e)}")
                # Fall through to default message
    
    except Exception as e:
        print(f"[ERROR] Query processing error: {str(e)}")
        # Continue to default fallback

    # ============================================================
    # Layer 6: Default Fallback (always returns a valid response)
    # ============================================================
    try:
        return (
            "I didn't understand that. Send blood test values in JSON, key=value, or CSV format.\n\n"
            "*Alternative ways to send lab reports:*\n"
            "- Take a screenshot/photo of your lab report and send as image\n"
            "- Send a public URL to your PDF (e.g., Google Drive share link)\n"
            "- Convert PDF to images and send them\n\n"
            "Type 'help' for instructions or 'template' for an example."
        )
    except Exception as e:
        # Final fallback - should never reach here, but ensures we always return something
        print(f"[CRITICAL] Even default fallback failed: {str(e)}")
        return "I'm having trouble processing your message. Please try again or type 'help'."


def handle_start() -> str:
    """Handle /start command."""
    return """*Welcome to MediGuard AI!*

I'm your clinical triage assistant powered by AI. Send me blood test results and I'll provide:

- Disease prediction & confidence
- Key biomarker analysis
- Medical references
- Risk assessment

*How to send lab reports:*
- Take a photo/screenshot of your lab report
- Send a public URL to your PDF (Google Drive, Dropbox, etc.)
- Or enter values manually using JSON/key-value/CSV format

*Get started:*
Type 'template' to see input format
Type 'help' for full instructions

_This is an AI assistant for educational/triage purposes. Always consult a healthcare provider for medical decisions._
"""


def handle_template_request(text: str) -> str:
    """Handle template request."""
    if "key" in text or "value" in text:
        return format_template_message("key_value")
    elif "csv" in text:
        return format_template_message("csv")
    else:
        return format_template_message("json")


def handle_reset(user_id: str) -> str:
    """Handle reset command."""
    update_session(
        user_id,
        mode="idle",
        last_prediction=None,
        last_references=None,
        pending_confirmation=0,
        pending_values=None,
    )
    secure_logger.audit("session_reset", user_id)
    return "Session cleared. Send new biomarker values or type 'help'."


def _fill_missing_biomarkers(biomarker_values: Dict[str, float]) -> Dict[str, float]:
    """
    Fill missing biomarkers with default values (normal range midpoints).
    
    Args:
        biomarker_values: Dictionary with available biomarker values
        
    Returns:
        Complete dictionary with all 24 biomarkers
    """
    import json
    import os
    
    # Load biomarker config for default values
    biomarker_config_path = os.path.join(
        os.path.dirname(__file__),
        "mediguard",
        "data",
        "biomarkers.json"
    )
    
    with open(biomarker_config_path, "r") as f:
        config = json.load(f)
    
    biomarkers_config = {b["id"]: b for b in config["biomarkers"]}
    complete = biomarker_values.copy()
    
    # Fill missing with normal range midpoints
    for biomarker_id in parser.BIOMARKER_ORDER:
        if biomarker_id not in complete:
            bio_config = biomarkers_config.get(biomarker_id)
            if bio_config:
                normal_range = bio_config.get("normal_range", {})
                min_val = normal_range.get("min", 0)
                max_val = normal_range.get("max", 1)
                # Use midpoint of normal range as default
                default_value = (min_val + max_val) / 2
                complete[biomarker_id] = default_value
    
    return complete


def handle_prediction_request(user_id: str, biomarker_values: Dict[str, float]) -> str:
    """
    Handle prediction request with parsed biomarker values.

    Args:
        user_id: User ID
        biomarker_values: Parsed biomarker values

    Returns:
        Formatted prediction response
    """
    try:
        print(f"[DEBUG] handle_prediction_request: Starting with {len(biomarker_values)} biomarkers")
        
        # Scale biomarkers
        print(f"[DEBUG] Scaling biomarkers...")
        scaling_result = scaler.scale_all(biomarker_values)
        scaled_values = scaling_result["scaled_values"]
        warnings = scaling_result["warnings"]
        raw_summary = scaling_result["raw_summary"]
        print(f"[DEBUG] Scaling complete. Warnings: {len(warnings)}")

        # Make prediction
        print(f"[DEBUG] Making prediction...")
        prediction_result = predictor.predict(scaled_values, biomarker_values)
        print(f"[DEBUG] Prediction complete: {prediction_result.get('prediction_name', 'Unknown')}")
        print(f"[DEBUG] Prediction confidence: {prediction_result.get('confidence', 0)*100:.1f}%")

        # Retrieve medical references
        print(f"[DEBUG] Retrieving medical references...")
        references = rag_engine.retrieve_references(
            prediction_result["prediction"],
            max_results=3
        )
        print(f"[DEBUG] Retrieved {len(references)} references")

        # Store in session for follow-up queries
        print(f"[DEBUG] Storing in session...")
        update_session(
            user_id,
            mode="reviewed",
            last_prediction=json.dumps(prediction_result),
            last_references=json.dumps(references),
        )

        # Log prediction (anonymized, no PHI)
        secure_logger.log_event(
            user_id,
            "prediction_generated",
            {
                "prediction": prediction_result["prediction"],
                "confidence": prediction_result["confidence"],
                "severity": prediction_result["severity"],
                "num_biomarkers": len(biomarker_values),
                "num_warnings": len(warnings),
            },
        )

        # Format response
        print(f"[DEBUG] Formatting response...")
        response = format_prediction_response(
            prediction_result,
            warnings,
            references
        )
        print(f"[DEBUG] Response formatted. Length: {len(response)} characters")
        print(f"[DEBUG] First 300 chars: {response[:300]}...")

        if not response or len(response.strip()) == 0:
            print(f"[ERROR] format_prediction_response returned empty string!")
            return "Error: Prediction response is empty. Please try again."

        return response

    except Exception as e:
        print(f"[ERROR] Exception in handle_prediction_request: {str(e)}")
        import traceback
        traceback.print_exc()
        secure_logger.audit("prediction_error", user_id, {"error": str(e)})
        return f"Error processing prediction: {str(e)}\n\nPlease check your input format and try again."


def handle_explain_more(user_id: str) -> str:
    """Handle 'explain more' request."""
    sess = get_session(user_id)

    if not sess["last_prediction"]:
        return "No recent prediction to explain. Please submit biomarker values first."

    try:
        prediction_result = json.loads(sess["last_prediction"])

        explanation = f"*üîç Detailed Analysis*\n\n"
        explanation += f"*Prediction:* {prediction_result['prediction_name']}\n"
        explanation += f"*Confidence:* {prediction_result['confidence']*100:.1f}%\n"
        explanation += f"*Severity Level:* {prediction_result['severity'].upper()}\n\n"

        explanation += f"*Full Explanation:*\n{prediction_result['explanation']}\n\n"

        # Detailed biomarker breakdown
        if prediction_result["key_biomarkers"]:
            explanation += "*Detailed Biomarker Analysis:*\n"
            for kb in prediction_result["key_biomarkers"]:
                explanation += (
                    f"\n{kb['direction']} *{kb['name']} ({kb['code']})*\n"
                    f"  Value: {kb['value']} {kb['unit']}\n"
                    f"  Status: {kb['status']}\n"
                    f"  Deviation: {kb['deviation']*100:.0f}% from normal\n"
                )

        # All probabilities
        explanation += "\n*All Disease Probabilities:*\n"
        for disease_id, prob in prediction_result["probabilities"].items():
            disease_name = disease_id.replace("_", " ").title()
            explanation += f"  {disease_name}: {prob*100:.1f}%\n"

        return explanation

    except Exception as e:
        return f"Error generating explanation: {str(e)}"


def handle_show_sources(user_id: str) -> str:
    """Handle 'show sources' request."""
    sess = get_session(user_id)

    if not sess["last_references"]:
        return "No references available. Please submit biomarker values first."

    try:
        references = json.loads(sess["last_references"])
        return rag_engine.format_references(references)

    except Exception as e:
        return f"Error retrieving sources: {str(e)}"


def handle_query(query_text: str) -> str:
    """
    Handle general medical query using RAG.

    Args:
        query_text: User's natural language query

    Returns:
        Response with relevant references
    """
    try:
        references = rag_engine.query(query_text)

        if not references:
            return (
                "I couldn't find specific references for that query. "
                "I'm primarily designed for blood test analysis.\n\n"
                "Send biomarker values or type 'help' for instructions."
            )

        response = f"*üìö References for: \"{query_text[:50]}...\"*\n\n"
        response += rag_engine.format_references(references)

        return response

    except Exception as e:
        return f"Error processing query: {str(e)}"


def handle_media_upload(user_id: str, media_info: Dict[str, Any], request_form: Dict[str, Any]) -> str:
    """
    Handle media upload (PDF/image lab report).

    Args:
        user_id: WhatsApp user ID
        media_info: Media information from Twilio
        request_form: Full request form data

    Returns:
        TwiML response string
    """
    print(f"\n[DEBUG] ========== handle_media_upload START ==========")
    print(f"[DEBUG] User ID: {user_id}")
    print(f"[DEBUG] Media Info: {media_info}")
    
    resp = MessagingResponse()
    
    try:
        # Log media upload
        print(f"[DEBUG] Logging media upload event...")
        secure_logger.log_event(
            user_id,
            "media_upload_received",
            {
                "media_type": media_info.get("media_content_type"),
                "num_media": media_info.get("num_media"),
                "timestamp": datetime.utcnow().isoformat(),
            },
        )

        # Download media file
        media_url = media_info.get("media_url")
        if not media_url:
            print(f"[ERROR] media_url is missing from media_info!")
            resp.message("Error: Media URL not found in request.")
            return str(resp)
            
        media_content_type = media_info.get("media_content_type", "")
        print(f"[DEBUG] Media URL: {media_url[:100]}...")
        print(f"[DEBUG] Media Content Type: {media_content_type}")
        
        # Get file extension from content type
        file_extension = None
        if "pdf" in media_content_type.lower():
            file_extension = ".pdf"
        elif "image" in media_content_type.lower():
            # Default to .jpg for images
            file_extension = ".jpg"

        # Check if this is a URL-based upload (workaround for PDF limitations)
        is_url_upload = media_info.get("message_type") == "url"
        
        if is_url_upload:
            print(f"[INFO] Downloading from public URL (workaround for PDF upload)...")
        else:
            print(f"[INFO] Downloading media from Twilio...")
            print(f"[DEBUG] Using Account SID: {TWILIO_ACCOUNT_SID[:10] if TWILIO_ACCOUNT_SID else 'None'}...")
        
        print(f"[DEBUG] File extension: {file_extension}")
        
        # For URL uploads, auth may not be needed (handled in download_media)
        file_path, error = media_handler.download_media(
            media_url,
            TWILIO_ACCOUNT_SID,
            TWILIO_AUTH_TOKEN,
            file_extension=file_extension
        )

        print(f"[DEBUG] Download result - File path: {file_path}, Error: {error}")

        if error or not file_path:
            print(f"[ERROR] Media download failed: {error}")
            print(f"[ERROR] Media URL was: {media_url[:200] if media_url else 'None'}...")
            secure_logger.audit("media_download_failed", user_id, {"error": error, "url": media_url[:200] if media_url else None})
            
            # Provide specific error message based on error type
            if error and "Google Drive" in error:
                error_msg = error  # Use the detailed Google Drive error message
            elif error and "HTML" in error:
                error_msg = error  # Use the HTML error message
            else:
                error_msg = f"Failed to download: {error}"
            
            resp.message(
                f"{error_msg}\n\n"
                "Please try:\n"
                "- For Google Drive: Share file with 'Anyone with the link'\n"
                "- Send a PDF or image file directly\n"
                "- Check file size (max 10MB)\n"
                "- Or use 'template' command to enter values manually"
            )
            print(f"[DEBUG] Returning error response to user")
            return str(resp)

        # Validate file
        is_valid, validation_error = media_handler.is_valid_lab_report(file_path)
        if not is_valid:
            media_handler.cleanup_temp_file(file_path)
            secure_logger.audit("media_validation_failed", user_id, {"error": validation_error})
            resp.message(
                f"Invalid lab report file: {validation_error}\n\n"
                "Supported formats: PDF, JPG, PNG\n"
                "Max size: 10MB\n\n"
                "Or use 'template' command to enter values manually."
            )
            return str(resp)

        # Process with OCR (Phase 2)
        file_info = media_handler.get_file_info(file_path)
        print(f"[DEBUG] File info: {file_info}")
        
        print(f"[INFO] Extracting text from lab report: {file_info['name']}")

        # Extract text using OCR
        try:
            print(f"[DEBUG] ========== STARTING OCR EXTRACTION ==========")
            print(f"[DEBUG] File path: {file_path}")
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                print(f"[DEBUG] File size: {file_size} bytes")
            else:
                print(f"[ERROR] File does not exist: {file_path}")
            
            ocr_result = ocr_engine.extract_text(file_path)
            ocr_text = ocr_result.get("text", "")
            ocr_method = ocr_result.get("method", "unknown")

            print(f"[DEBUG] OCR Result:")
            print(f"[DEBUG]   Method: {ocr_method}")
            print(f"[DEBUG]   Text length: {len(ocr_text) if ocr_text else 0}")
            print(f"[DEBUG]   First 200 chars: {ocr_text[:200] if ocr_text else '(empty)'}...")

            if not ocr_text or len(ocr_text.strip()) < 50:
                media_handler.cleanup_temp_file(file_path)
                secure_logger.audit("ocr_extraction_failed", user_id, {"method": ocr_method})
                resp.message(
                    "Could not extract text from lab report.\n\n"
                    "Please try:\n"
                    "- Send a clearer PDF/image\n"
                    "- Ensure text is readable\n"
                    "- Or use 'template' command to enter values manually"
                )
                return str(resp)

            print(f"[OK] OCR extraction successful ({ocr_method}): {len(ocr_text)} characters")

            # Extract biomarker values from OCR text
            print(f"[INFO] Extracting biomarker values...")
            biomarker_values, extraction_errors = biomarker_extractor.extract_from_text(ocr_text)

            if not biomarker_values:
                media_handler.cleanup_temp_file(file_path)
                secure_logger.audit("biomarker_extraction_failed", user_id, {
                    "ocr_method": ocr_method,
                    "errors": extraction_errors
                })
                resp.message(
                    "Could not extract biomarker values from lab report.\n\n"
                    f"Errors: {', '.join(extraction_errors[:3])}\n\n"
                    "Please try:\n"
                    "- Send a clearer lab report\n"
                    "- Or use 'template' command to enter values manually"
                )
                return str(resp)

            # Count found biomarkers
            found_biomarkers = sum(1 for v in biomarker_values.values() if v is not None)
            missing_biomarkers = 24 - found_biomarkers

            print(f"[OK] Extracted {found_biomarkers}/24 biomarkers")

            # Filter out None values for processing
            valid_biomarkers = {k: v for k, v in biomarker_values.items() if v is not None}

            if len(valid_biomarkers) < 5:
                media_handler.cleanup_temp_file(file_path)
                resp.message(
                    f"Too few biomarkers found ({found_biomarkers}/24).\n\n"
                    "Please try:\n"
                    "- Send a complete lab report\n"
                    "- Or use 'template' command to enter values manually"
                )
                return str(resp)

            # Fill missing biomarkers with default values (normal range midpoints)
            # This allows prediction to work with partial data
            complete_biomarkers = _fill_missing_biomarkers(valid_biomarkers)
            
            if missing_biomarkers > 0:
                print(f"[WARN] Missing {missing_biomarkers} biomarkers, using defaults for missing values")

            # Process prediction with complete biomarker set
            print(f"[DEBUG] Calling handle_prediction_request with {len(complete_biomarkers)} biomarkers...")
            reply_text = handle_prediction_request(user_id, complete_biomarkers)
            print(f"[DEBUG] handle_prediction_request returned text (length: {len(reply_text) if reply_text else 0})")
            print(f"[DEBUG] First 200 chars of reply_text: {reply_text[:200] if reply_text else '(empty)'}...")

            if not reply_text or len(reply_text.strip()) == 0:
                print(f"[ERROR] handle_prediction_request returned empty or None response!")
                resp.message(
                    "Successfully extracted biomarkers, but prediction failed.\n\n"
                    "Please try again or contact support."
                )
                media_handler.cleanup_temp_file(file_path)
                return str(resp)

            # Add extraction info to response
            extraction_info = f"*Extraction Summary:*\nFound: {found_biomarkers}/24 biomarkers\nMethod: {ocr_method.upper()}\n\n"
            if missing_biomarkers > 0:
                extraction_info += f"Note: {missing_biomarkers} biomarkers not found, using normal range defaults.\n\n"
            
            full_reply = extraction_info + reply_text
            print(f"[DEBUG] Full reply length: {len(full_reply)} characters")

            # Cleanup temp file after processing
            media_handler.cleanup_temp_file(file_path)

            # Send response
            chunks = chunk_message(full_reply, max_length=1500)
            print(f"[DEBUG] Message chunked into {len(chunks)} chunk(s)")
            for i, chunk in enumerate(chunks):
                print(f"[DEBUG] Adding chunk {i+1}/{len(chunks)} to response (length: {len(chunk)})")
                resp.message(chunk)

            print(f"[OK] Lab report processed successfully: {found_biomarkers}/24 biomarkers extracted")
            print(f"[DEBUG] ========== handle_media_upload SUCCESS ==========")
            print(f"[DEBUG] Final response length: {len(str(resp))} characters")
            return str(resp)

        except Exception as e:
            print(f"[ERROR] Exception in OCR processing block: {str(e)}")
            import traceback
            traceback.print_exc()
            
            if 'file_path' in locals() and file_path:
                media_handler.cleanup_temp_file(file_path)
            
            secure_logger.audit("ocr_processing_error", user_id, {
                "error": str(e),
                "error_type": type(e).__name__,
                "media_url": media_info.get("media_url", "")[:200] if media_info else None
            })
            
            # Provide more specific error message
            error_detail = str(e)
            if "Gemini" in error_detail or "API" in error_detail:
                error_msg = "OCR service error. Please try again or use 'template' command."
            elif "Tesseract" in error_detail or "OCR" in error_detail:
                error_msg = "Could not read text from image. Please send a clearer image or use 'template' command."
            else:
                error_msg = f"Processing error: {error_detail[:100]}"
            
            resp.message(
                f"Error processing lab report: {error_msg}\n\n"
                "Please try:\n"
                "- Send a clearer PDF/image\n"
                "- Ensure text is readable\n"
                "- Or use 'template' command to enter values manually"
            )
            print(f"[DEBUG] ========== handle_media_upload ERROR (OCR) ==========")
            return str(resp)

    except Exception as e:
        print(f"[ERROR] Exception in handle_media_upload: {str(e)}")
        import traceback
        traceback.print_exc()
        
        error_type = type(e).__name__
        error_msg = str(e)
        media_url = media_info.get("media_url", "")[:200] if media_info else None
        
        secure_logger.audit("media_processing_error", user_id, {
            "error": error_msg,
            "error_type": error_type,
            "media_url": media_url,
            "media_type": media_info.get("message_type") if media_info else None
        })
        
        # Provide more helpful error message
        if "download" in error_msg.lower() or "connection" in error_msg.lower():
            user_error = "Failed to download the file. Please check the URL is accessible."
        elif "permission" in error_msg.lower() or "access" in error_msg.lower():
            user_error = "File access denied. For Google Drive, share with 'Anyone with the link'."
        else:
            user_error = f"Error: {error_msg[:150]}"
        
        resp.message(
            f"An error occurred processing your lab report.\n\n"
            f"{user_error}\n\n"
            "Please try:\n"
            "- For Google Drive: Share file with 'Anyone with the link'\n"
            "- Send a clearer PDF/image\n"
            "- Or use 'template' command to enter values manually"
        )
        print(f"[DEBUG] ========== handle_media_upload ERROR (Outer) ==========")
        return str(resp)


# ---------------------------
# Flask Routes
# ---------------------------

@app.before_request
def log_all_requests():
    """Log ALL incoming requests for debugging."""
    print(f"\n{'='*60}")
    print(f"[DEBUG] ===== INCOMING REQUEST =====")
    print(f"[DEBUG] Method: {request.method}")
    print(f"[DEBUG] Path: {request.path}")
    print(f"[DEBUG] URL: {request.url}")
    print(f"[DEBUG] Remote Address: {request.remote_addr}")
    print(f"[DEBUG] Headers: {dict(request.headers)}")
    if request.method == "POST":
        print(f"[DEBUG] Form data: {dict(request.form)}")
        if request.is_json:
            print(f"[DEBUG] JSON data: {request.get_json(silent=True)}")
    print(f"{'='*60}\n")


@app.route("/", methods=["GET", "POST"])
def root():
    """Root endpoint."""
    if request.method == "POST":
        # Twilio is sending POST to / instead of /whatsapp
        # Log the issue and return helpful error
        print("[WARN] WARNING: Received POST request to / instead of /whatsapp")
        print(f"   Request data: {dict(request.form)}")
        return {
            "error": "Webhook endpoint is /whatsapp, not /",
            "message": "Please configure Twilio webhook URL to: https://your-domain.com/whatsapp",
            "current_path": "/",
            "correct_path": "/whatsapp"
        }, 400
    return "MediGuard AI WhatsApp Bot is running."


@app.route("/whatsapp", methods=["POST", "GET"])
def whatsapp_webhook():
    """WhatsApp webhook endpoint."""
    # Handle GET requests (webhook verification)
    if request.method == "GET":
        print(f"[INFO] GET request to /whatsapp (webhook verification)")
        return "Webhook endpoint is active. Use POST for messages.", 200
    
    try:
        init_db()  # Ensure tables exist

        from_number = request.form.get("From", "")
        body = request.form.get("Body", "").strip()
        user_id = from_number or "unknown"
        
        # Check for Twilio error codes (e.g., 11200 = HTTP retrieval failure)
        error_code = request.form.get("ErrorCode", "")
        if error_code:
            print(f"[WARN] Twilio ErrorCode detected: {error_code}")
            if error_code == "11200":
                print(f"[WARN] ErrorCode 11200: HTTP retrieval failure - Twilio couldn't fetch media")
                # Still try to extract media - sometimes URL is available even with error
            else:
                print(f"[WARN] Unknown error code: {error_code}")

        # DEBUG: Log all incoming request data
        print(f"\n{'='*60}")
        print(f"[DEBUG] WhatsApp Webhook Received")
        print(f"[DEBUG] User ID: {user_id}")
        print(f"[DEBUG] Body: {body[:100] if body else '(empty)'}")
        print(f"[DEBUG] ErrorCode: {error_code if error_code else 'None'}")
        print(f"[DEBUG] NumMedia: {request.form.get('NumMedia', '0')}")
        print(f"[DEBUG] MediaUrl0: {request.form.get('MediaUrl0', 'None')[:100] if request.form.get('MediaUrl0') else 'None'}")
        print(f"[DEBUG] MediaContentType0: {request.form.get('MediaContentType0', 'None')}")
        print(f"[DEBUG] MessageType: {request.form.get('MessageType', 'None')}")
        print(f"[DEBUG] All form keys: {list(request.form.keys())}")
        print(f"[DEBUG] All form values:")
        for key, value in request.form.items():
            if isinstance(value, str) and len(value) > 100:
                print(f"[DEBUG]   {key}: {value[:100]}...")
            else:
                print(f"[DEBUG]   {key}: {value}")
        print(f"{'='*60}\n")

        # Check for media attachments (PDF/image lab reports) FIRST
        # This must happen even if Body is empty (ErrorCode 11200 case)
        media_info = extract_media_from_twilio_request(dict(request.form))
        if media_info:
            print(f"[INFO] [OK] Media detected! Type: {media_info.get('media_content_type', 'unknown')}")
            print(f"[INFO] Media URL: {media_info.get('media_url', '')[:100]}...")
            
            # If ErrorCode 11200, add warning to response
            if error_code == "11200":
                print(f"[WARN] Processing media despite ErrorCode 11200 - Twilio retrieval failed, but URL may still be accessible")
            
            result = handle_media_upload(user_id, media_info, dict(request.form))
            print(f"[DEBUG] handle_media_upload returned response (length: {len(result) if result else 0})")
            return result
        
        # Handle ErrorCode 11200 case (media upload failed by Twilio)
        if error_code == "11200" and not body:
            print(f"[ERROR] ErrorCode 11200: Twilio couldn't retrieve media and no body text")
            resp = MessagingResponse()
            resp.message(
                "I received your media upload, but Twilio couldn't retrieve it.\n\n"
                "Please try:\n"
                "- For PDFs: Send as image instead, or share via Google Drive link\n"
                "- For images: Ensure file is under 10MB and in JPG/PNG format\n"
                "- Or use 'template' command to enter values manually"
            )
            return str(resp)

        # IMPORTANT: Process ALL text messages through handle_message
        # This allows JSON/key-value/CSV input to be parsed correctly
        # URL detection happens INSIDE handle_message, AFTER biomarker parsing
        print(f"[INFO] No media detected, processing as text message")
        print(f"[INFO] Received message from {user_id}: {body[:50] if body else '(empty)'}...")

        # Process text message
        try:
            reply_text = handle_message(user_id, body if body else "")
            print(f"[DEBUG] handle_message returned: {reply_text[:100] if reply_text else '(empty)'}...")
        except Exception as e:
            print(f"[ERROR] Error in handle_message: {str(e)}")
            import traceback
            traceback.print_exc()
            reply_text = f"Error processing message: {str(e)}. Please try again or type 'help'."

        # Send response (chunked if necessary)
        if not reply_text or len(reply_text.strip()) == 0:
            print(f"[WARN] Empty reply text, sending default message")
            reply_text = "I received your message but couldn't process it. Type 'help' for instructions."
        
        try:
            resp = MessagingResponse()
            chunks = chunk_message(reply_text, max_length=1500)

            for chunk in chunks:
                resp.message(chunk)

            print(f"[OK] Sent response ({len(chunks)} chunk(s), total length: {len(reply_text)} chars)")
            response_str = str(resp)
            print(f"[DEBUG] Response XML length: {len(response_str)}")
            return response_str
        except Exception as e:
            print(f"[ERROR] Error creating response: {str(e)}")
            import traceback
            traceback.print_exc()
            # Try to send at least an error message
            try:
                resp = MessagingResponse()
                resp.message("Error processing your message. Please try again or type 'help'.")
                return str(resp)
            except Exception as e3:
                print(f"[ERROR] Final fallback failed: {str(e3)}")
                return '<?xml version="1.0" encoding="UTF-8"?><Response><Message>Error. Please try again.</Message></Response>'
    
    except Exception as e:
        print(f"[ERROR] Error in whatsapp_webhook: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return error response to Twilio
        try:
            resp = MessagingResponse()
            resp.message("An error occurred processing your message. Please try again or type 'help'.")
            return str(resp)
        except Exception as e2:
            print(f"[ERROR] Failed to create error response: {str(e2)}")
            # Return minimal valid TwiML
            return '<?xml version="1.0" encoding="UTF-8"?><Response><Message>Error. Please try again.</Message></Response>'


@app.route("/health", methods=["GET"])
def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "service": "mediguard-bot"}, 200


@app.route("/debug", methods=["GET", "POST"])
def debug_endpoint():
    """Debug endpoint to see incoming requests."""
    print(f"\n[DEBUG] Debug endpoint called - Method: {request.method}")
    print(f"[DEBUG] Form data: {dict(request.form)}")
    print(f"[DEBUG] Headers: {dict(request.headers)}")
    return {
        "method": request.method,
        "path": request.path,
        "url": request.url,
        "form_data": dict(request.form),
        "headers": dict(request.headers),
        "message": "This is a debug endpoint. Webhook should be at /whatsapp",
        "bot_status": "running",
        "endpoints": {
            "webhook": "/whatsapp",
            "health": "/health",
            "debug": "/debug"
        }
    }, 200


@app.route("/test", methods=["GET", "POST"])
def test_endpoint():
    """Test endpoint to verify server is accessible."""
    print(f"\n[DEBUG] Test endpoint called - Method: {request.method}")
    return {
        "status": "ok",
        "message": "Server is running and accessible",
        "timestamp": datetime.utcnow().isoformat(),
        "method": request.method,
        "received_data": dict(request.form) if request.method == "POST" else {}
    }, 200


# ---------------------------
# Cleanup Task (run periodically)
# ---------------------------

def cleanup_expired_logs():
    """Cleanup expired logs (should be run via cron/scheduler)."""
    deleted = secure_logger.cleanup_expired_logs()
    print(f"Cleaned up {deleted} expired log entries")


# ---------------------------
# Main Entry Point
# ---------------------------

if __name__ == "__main__":
    port = int(os.getenv("PORT", "5000"))
    init_db()
    print(f"\n{'='*60}")
    print(f"üöÄ MediGuard AI Bot starting on port {port}...")
    print(f"{'='*60}")
    print(f"\nüìã WEBHOOK CONFIGURATION REQUIRED:")
    print(f"   1. For local testing, use ngrok:")
    print(f"      ngrok http {port}")
    print(f"   2. Copy the ngrok HTTPS URL (e.g., https://abc123.ngrok.io)")
    print(f"   3. In Twilio Console, set webhook URL to:")
    print(f"      https://abc123.ngrok.io/whatsapp")
    print(f"   4. Make sure webhook method is set to 'POST'")
    print(f"\nüì° Available endpoints:")
    print(f"   - POST /whatsapp (Twilio webhook - REQUIRED)")
    print(f"   - GET  /health (health check)")
    print(f"   - GET  /debug (debug info)")
    print(f"   - GET  /test (test endpoint)")
    print(f"\nüîç ALL requests will be logged to console")
    print(f"{'='*60}\n")
    app.run(host="0.0.0.0", port=port, debug=True)  # Enable debug for better logging
